#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""pymkecli Client

   synchronous client for communication with sensor
"""

__author__ = "Ondra Fisar"
__copyright__ = "Copyright (c) 2017-2019, Magik-Eye s.r.o., Prague"

# ------------------------------------------------------------------------------

# imports

import struct
import numpy as np
import collections
import inspect

import pymkecli.bus

# API -------------------------------------------------------------------------

class Api:

    # API status -----
  
    STATUS_DATA_WILL_START                = 100
    STATUS_DATA_WILL_CONTINUE             = 101
    STATUS_DATA_STOPPED                   = 102
  
    STATUS_OK                             = 200
  
    STATUS_CLIENT_ERROR                   = 400
    STATUS_CLIENT_MALFORMED_REQUEST       = 401
    STATUS_CLIENT_ILLEGAL_REQUEST_TYPE    = 402
    STATUS_CLIENT_REQUEST_DOES_NOT_APPLY  = 403
  
    STATUS_SERVER_ERROR                   = 500
    STATUS_SERVER_REQUEST_INTERRUPTED     = 501
    STATUS_SERVER_BUSY                    = 502
    STATUS_SERVER_INSUFFICIENT_RESOURCES  = 503
    STATUS_SERVER_FATAL_ERROR             = 504

    # API Calls -----
    
    CMD_TERMINATE                         = 10
    CMD_GET_FIRMWARE_INFO                 = 11
    CMD_GET_DEVICE_INFO                   = 12
    CMD_GET_STATE                         = 20
    CMD_SET_STATE                         = 21
    CMD_GET_POLICY                        = 22
    CMD_SET_POLICY                        = 23
    CMD_START_FRAME_PUSH                  = 24
    CMD_STOP_FRAME_PUSH                   = 25
    CMD_GET_FRAME                         = 26
    CMD_LIST_POLICIES                     = 27

    # API State enums -----

    STATE_IDLE                            = 1
    STATE_DEPTH_SENSOR                    = 2
  
    # API Terminate enums -----
    
    TERMINATE_REBOOT                      = 1
    TERMINATE_SHUTDOWN                    = 2
    
    # API FrameType enum
    
    FRAME_TYPE_1                          = 1
    FRAME_TYPE_2                          = 2
    
    # API Data3D enum
    
    DATA3D_MM                             = 0
    DATA3D_MM2                            = 1
    DATA3D_MM4                            = 2
    DATA3D_MM8                            = 3
    DATA3D_MM16                           = 4
    
    class Error(RuntimeError):
        
        def __init__(self, message, ret_code, seq_id):
            nw_msg = message + " (received ret_code: %d:%s, @%d)" % (ret_code, 
                                 Api.Error.ret_code_to_string(ret_code), seq_id)
            super(RuntimeError, self).__init__(nw_msg)
            
            self.__orig_msg = message
            self.ret_code = ret_code
            self.seq_id = seq_id

        def __reduce__(self):
            return (Api.Error, (self.__orig_msg, self.ret_code, self.seq_id))
            
        @staticmethod
        def ret_code_to_string(ret_code):
            """Translate ret_code into string enum."""
            for (name, value) in inspect.getmembers(Api):
                if name.startswith('STATUS_') and value == ret_code:
                    return name
            return "!INVALID_RET_CODE!"

    # -----
    
    class Request:
        """Class to cover API request"""
        __slots__ = 'cmd', 'seq_id', 'params'
    
        __MAGIC_HEAD    = b'MKERQ100'
        __PARAMS_LEN    = 8
        
        def __init__(self, cmd, seq_id=None, params=bytearray(__PARAMS_LEN)):
            """Contruct new Api.Request.
            
            Arguments:
            cmd: API command of request
            seq_id: `sequnce_id` of the request. Could be None, will be auto-generated by Bus
            params: request parameters
            """
            assert(len(params) == Api.Request.__PARAMS_LEN)
    
            self.cmd = cmd
            self.seq_id = seq_id
            self.params = params

        def __str__(self):
            """Stringify object"""
            return "ApiRequest: (cmd: %d, seq_id: %d, params: %s" % (
                    self.cmd, self.seq_id, str(self.params))
        
        def assemble(self):
            """Assemble request."""
            cmd_b = bytes("%04d" % self.cmd, 'ascii')
            seq_id_b = struct.pack('<I', self.seq_id)
            return Api.Request.__MAGIC_HEAD + cmd_b + seq_id_b + self.params
    
    # -----
    
    class Reply:
        """Class to wrap API reply.
        
        Properties:
        cmd: API command reply answering to.
        ret_code: Return code of the reply.
        seq_id: `sequence_id` of request reply answering to.
        params: reply params
        payload: payload of reply
        """
    
        __slots__ = 'cmd', 'ret_code', 'seq_id', 'params', 'payload'
    
        __MAGIC_HEAD    = b'MKERP100'
        __PACKET_LEN    = 48
        __PARAMS_LEN    = 24
            
        def __str__(self):
            """Stringify object"""
            return "ApiReply: (cmd: %d, ret_code: %d, seq_id: %d, params: %s, len(payload): %d" % (
                    self.cmd, self.ret_code, self.seq_id, str(self.params), len(self.payload))            
            
        def parse(self, data):
            """Parse reply from given data. 
            Returns tuple:
            [0]: status of parsing (True/False)
            [1]: required/used size of data.
            """
            if len(data) < Api.Reply.__PACKET_LEN:
                return (False, Api.Reply.__PACKET_LEN)
            
            if not data.startswith(Api.Reply.__MAGIC_HEAD):
                raise RuntimeError("Received BAD magic: " + str(data[0:len(Api.Reply.__MAGIC_HEAD)]))
                
            payload_size = struct.unpack('<I', data[20:24])[0];
            
            if len(data) < (Api.Reply.__PACKET_LEN + payload_size):
                return (False, Api.Reply.__PACKET_LEN + payload_size)
            
            self.cmd = int(data[8:12])
            self.ret_code = int(data[12:16])
            self.seq_id, = struct.unpack('<I', data[16:20])
            self.params = bytes(data[24:48])
            self.payload = bytes(data[48:48+payload_size])
            
            return (True, Api.Reply.__PACKET_LEN + payload_size)

# ------------------------------------------------------------------------------

class Frame:
    """Frame object with detections"""
    __slots__ = 'timer', 'seqn', 'data_type', 'frame_type', 'uid', 'lut3d', 'lutid'
    
    __FRAME_ITEM_SIZES = {Api.FRAME_TYPE_1: 8, 
                          Api.FRAME_TYPE_2: 12}
    __DATA_TYPE_FACTOR = {Api.DATA3D_MM:    1.0,
                          Api.DATA3D_MM2:   0.5,
                          Api.DATA3D_MM4:   0.25,
                          Api.DATA3D_MM8:   0.125,
                          Api.DATA3D_MM16:  0.0625}
    
    def parse(self, params, payload):
        """Parse frame from its binnary form."""
        (self.timer, self.seqn, self.data_type, self.frame_type, num_pts) = struct.unpack('<QQIHH', params)
        self.parse_payload_only(num_pts, payload)

    def parse_payload_only(self, num_pts, payload):
        """Parse payload only."""
        # prepare memory
        
        self._prepare(num_pts)        
            
        # fill memory
        
        for i in range(num_pts):
            frame_item_size = self._frame_item_size(self.frame_type)
            item_data = payload[i*frame_item_size:(i+1)*frame_item_size]
            self._parse_frame_item(i, item_data)    
        
        # post-process detections

        self.lut3d *= Frame.__DATA_TYPE_FACTOR.get(self.data_type)

    def _prepare(self, num_pts):
        """Prepare structures before parsering"""
        self.uid = np.empty(num_pts)
        self.lut3d = np.empty((num_pts,3))
        if self.frame_type >= Api.FRAME_TYPE_2:
            self.lutid = np.empty((num_pts,2))
        else:
            self.lutid = None

    
    def _parse_frame_item(self, idx, item_data):
        """Parse single frame item."""
        self.uid[idx] = struct.unpack('<H', item_data[0:2])[0]
        self.lut3d[idx,:] = struct.unpack('<hhh', item_data[2:8])

        if self.frame_type >= Api.FRAME_TYPE_2:
            self.lutid[idx,:] = struct.unpack('<HH', item_data[8:12])
        
    def _frame_item_size(self, frame_type):
        """Return frame item size"""
        return Frame.__FRAME_ITEM_SIZES[frame_type]
        

# ------------------------------------------------------------------------------

class SyncClient:
    """Synchronous client"""
    __slots__ = '__bus', '_default_frame_type'
    
    FwInfo = collections.namedtuple('FwInfo', ['posixtime', 'git_commit', 
                                               'fw_version', 'sys_version'])
    DeviceInfo = collections.namedtuple('DeviceInfo', ['unit_id'])
    
    def __init__(self, bus):
        """Connect to the sensor by bus"""
        self.__bus = bus
        self.__print_connected()
        self._default_frame_type = Frame
      
    # PUBLIC CALLS ===========================================
  
    def terminate(self, method):
        """Terminates the sensor (reboot or shutdown)."""
        # terminate does not send reply
        params = struct.pack('<I', method) + bytearray(4)
        return self.__bus.send_request(Api.Request(cmd=Api.CMD_TERMINATE,
                                                   params=params))

    def get_fw_info(self):
        """Get Firmware info. Returns tuple of 3 numbers (major, minor, patch)."""
        reply = self._send_and_check(Api.Request(Api.CMD_GET_FIRMWARE_INFO),
                                    [Api.STATUS_OK])
        
        buildtime, commit_no = struct.unpack('<QI', reply.params[0:12])
        fw_ver = struct.unpack('BBB', reply.params[12:15])
        sys_ver = struct.unpack('BBB', reply.params[15:18])
        
        return SyncClient.FwInfo(posixtime=buildtime,
                                 git_commit=commit_no,
                                 fw_version=fw_ver,
                                 sys_version=sys_ver)
          
    def get_device_info(self):
        """Returns description of the sensor"""      
        reply = self._send_and_check(Api.Request(Api.CMD_GET_DEVICE_INFO),
                                     [Api.STATUS_OK])
        return SyncClient.DeviceInfo(unit_id=reply.params[0:8])
  
    def get_state(self):
        """Returns current state of the sensor."""
        reply = self._send_and_check(Api.Request(Api.CMD_GET_STATE),
                                     [Api.STATUS_OK])
        return struct.unpack('<I', reply.params[0:4])[0]
  
    def set_state(self, state):
        """Set state to `state`."""
        params = struct.pack('<I', state) + bytearray(4)
        self._send_and_check(Api.Request(Api.CMD_SET_STATE,
                                         params=params),
                             [Api.STATUS_OK])
  
    def start_frame_push(self, frame_type):
        """Start pushing frames (with `frame_type`) from sensor. 
        Returns `sequence id` of the request.
        """    
        params = struct.pack('<H', frame_type) + bytearray(6)
        reply = self._send_and_check(Api.Request(Api.CMD_START_FRAME_PUSH, 
                                                 params=params),
                                     [Api.STATUS_DATA_WILL_START])
        return reply.seq_id
  
  
    def stop_frame_push(self):
        """Stop pushing frames form sensor. 
        Returns `sequence id` of the request
        """
        return self.__bus.send_request(Api.Request(Api.CMD_STOP_FRAME_PUSH))

    def get_frame(self, frame_type):
        """Return current frame.
      
        Arguments:
        frame_type: Type of the desired frame
        """        
        params = struct.pack('<H', frame_type) + bytearray(6)
        reply = self._send_and_check(Api.Request(Api.CMD_GET_FRAME, params=params),
                                     [Api.STATUS_OK])
        frame = self._default_frame_type()
        frame.parse(reply.params, reply.payload)
        return frame
  
    def get_pushed_frame(self, start_seq_id, stop_seq_id=None):
        """Returns next frame pushed from the sensor by `start_frame_push` call.
        """
        reply = Api.Reply()
        self.__bus.recv_reply(reply)
        
        if reply.seq_id == start_seq_id:       # received reply from start_frame_push
          
            if reply.ret_code == Api.STATUS_DATA_STOPPED \
                  or reply.ret_code == Api.STATUS_SERVER_REQUEST_INTERRUPTED:  # this is last reply
                return None
          
            # reply should have STATUS_DATA_WILL_CONTINUE status
          
            if reply.ret_code != Api.STATUS_DATA_WILL_CONTINUE:
                raise RuntimeError("Unexpected reply with code %d from start_frame_push" % reply.ret_code)
            
            frame = self._default_frame_type()
            frame.parse(reply.params, reply.payload)
            return frame
        
        elif reply.seq_id == stop_seq_id:      # received reply from stop_frame_push
    
            # reply should be STATUS_OK
          
            if reply.ret_code != Api.STATUS_OK:
                raise RuntimeError("Unexpected reply with code %d from stop_frame_push" % reply.ret_code)
          
            # ignore this message and read next until STATUS_DATA_STOPPED
          
            return self.get_pushed_frame(start_seq_id, stop_seq_id)
        
        else:
            raise RuntimeError("Unexpected reply with seq_id %d" % reply.seq_id)
  
    def get_policy(self):
        """Get current policy."""
        reply = self._send_and_check(Api.Request(Api.CMD_GET_POLICY),
                                     [Api.STATUS_OK])

        return str(reply.params, 'ascii').rstrip('\0');

    def set_policy(self, policy_name):
        """Set profile to the sensor."""
        assert(type(policy_name) == str)
        
        params = bytes(policy_name,'ascii')
        if len(params) > 8:
            raise RuntimeError("Policy name is too long")
        params += bytes(8-len(params))
        
        self._send_and_check(Api.Request(Api.CMD_SET_POLICY,
                                         params=params),
                             [Api.STATUS_OK])
  
    def list_policies(self):
        """List policies."""
        reply = self._send_and_check(Api.Request(Api.CMD_LIST_POLICIES),
                                     [Api.STATUS_OK])

        return str(reply.payload, 'ascii').rstrip('\0').split('\0');
    
    # PRIVATE/PROTECTED METHODS -----------------------------------------------

    def __print_connected(self):
        """Print into verbose stream that client is connected"""
        fw_info = self.get_fw_info()
        dev_info = self.get_device_info()
        self.__bus.verbose_print(pymkecli.bus.DefaultBus.VERBOSE_INFO, 
                            "Connected to device with FW_VER: %s (SYS_VER: %s) on device %s:" % 
                  ('.'.join([str(v) for v in fw_info.fw_version]),
                   '.'.join([str(v) for v in fw_info.sys_version]),
                   dev_info.unit_id.decode('ascii')))
  
    def _send_and_check(self, api_request, expected_ret_codes=None):
        """Send Api.Request and check and returns Api.Reply.
        Checking ret code must be in list `expected_ret_codes`.
        """
        seq_id = self.__bus.send_request(api_request)
        reply = Api.Reply()
        self.__bus.recv_reply(reply)

        assert(api_request.cmd == reply.cmd and seq_id == reply.seq_id)
    
        if expected_ret_codes is not None and not reply.ret_code in expected_ret_codes:
            raise Api.Error("Unexpected reply status code", reply.ret_code, reply.seq_id)

        return reply
  
# -----------------------------------------------------------------------------
